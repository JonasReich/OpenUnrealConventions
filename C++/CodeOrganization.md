<sub>[Home](../README.md) / [C++](./README.md) / Code Organization </sub>

# C++ Code Organization

Base rules for all code organization:
- Files, classes, etc. should be organized with the reader in mind rather than the writer.
- Access should be restricted on a minimal API and expose as little of the implementation as possible.

## File Organization

- Use public/private folders for plugin source code to separate public header files from private source files
- Consider grouping POD type declarations and interface declarations in separate folders

## Header File Organization

- All declarations belong in header files
- If a type is restricted to internal/private, use a header file in the private folder instead of declaring it directly in the source file
    - Exception #1: Macro based declarations of utility types like log categories, stat groups, etc
    - Exception #2: Super short utility functions (< 15 lines of code)

- Header files follow this structure:
    1. Copyright
    2. ``#pragma once``
    3. Includes
        1. engine includes
        2. custom code includes
        3. generated header file
    4. Forward declarations
    5. One or more "main type" declarations, each consisting of
        1. Macro based utility type declarations required for main type (log categories, delegate types, etc)
        2. Main type (e.g. a uclass, uenum, etc)
        3. Dependent type overloads (e.g. LexToString overlaod, type traits)

## Source File Organization

Source files follow this structure:
1. Includes
    1. associated header file
    2. other headers sorted alphabetically
2. Type declarations (limited as described in [Header File Organization]())
3. External variable/member definitions
4. Function definitions in the same order as the declarations in the header file

## Class Member Organization

Use the following sorting of members:
1. Access Level
    - Sort declarations by access level: public, protected, private
    - One big continuous block per access specifier
    - Prefer private over protected and protected over public
    - Expanding access later on is a lot easier than restricting access
2. Member Type
    - Constructors
    - Static member functions providing access to the class itself
    - Nested types
    - Member Fields
        - uproperties
        - non-uproperties
    - Member Functions
        - All overrides grouped by parent type like this:
            ```cpp
            // - ParentTypeName
            virtual void SomeFunction() override;
            virtual void SomeOtherFunction() override;
            // --
            ```
        - Group function overloads together
        - Group by domain

## Namespaces

- You can use namespaces for non-reflected types (types without code generated by Unreal Header Tool).
- Watch out for the usual namespace pitfalls
    - Naming collisions
    - Missing namespace for forward declarations/function definitions
- using namespace rules:
    - Do not put "using" namespace declarations in the global scope, even in a .cpp file (it will cause problems with UE4s "unity" build system.)
    - It is fine to put using declarations within another namespace or function body
